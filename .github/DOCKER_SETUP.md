# Docker Setup Summary

This document provides an overview of the Docker infrastructure for Stock Tracking DC, inspired by InvenTree's architecture.

## Architecture Overview

The application uses a multi-container Docker setup with 5 services:

```
┌─────────────────────────────────────────────────────────────┐
│                     Docker Network (stockdc-network)        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │   Frontend  │  │   Backend   │  │   Worker    │         │
│  │   (nginx)   │  │ (Gunicorn)  │  │   (Celery)  │         │
│  │   Port 3000 │  │  Port 8000  │  │             │         │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘         │
│         │                │                │                 │
│         └────────────────┼────────────────┘                 │
│                          │                                  │
│         ┌────────────────┴────────────────┐                 │
│         │                                 │                 │
│  ┌──────▼──────┐                  ┌──────▼──────┐          │
│  │   MySQL     │                  │    Redis    │          │
│  │   Port 3306 │                  │  Port 6379  │          │
│  └─────────────┘                  └─────────────┘          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## Services

### 1. Database (MySQL 8.0)
- **Container**: `stockdc-db`
- **Port**: 3306
- **Purpose**: Primary database for all application data
- **Volume**: `db_data` (persistent storage)
- **Health Check**: `mysqladmin ping`

### 2. Cache/Broker (Redis 7)
- **Container**: `stockdc-redis`
- **Port**: 6379
- **Purpose**:
  - Django cache backend
  - Session storage
  - Celery message broker
- **Health Check**: `redis-cli ping`

### 3. Backend (Django + Gunicorn)
- **Container**: `stockdc-backend`
- **Port**: 8000
- **Production**: Gunicorn WSGI server with 4 workers
- **Development**: Django runserver with auto-reload
- **Volumes**:
  - `static_data`: Collected static files
  - `media_data`: User uploads
- **Health Check**: HTTP request to `/api/v1/health/`

### 4. Background Worker (Celery)
- **Container**: `stockdc-worker`
- **Production**: 2 concurrent workers
- **Development**: 1 worker with debug logging
- **Purpose**: Asynchronous task processing (emails, reports, etc.)

### 5. Frontend (React + nginx)
- **Container**: `stockdc-frontend`
- **Port**: 3000 (production), 5173 (development)
- **Production**: nginx serving pre-built static files
- **Development**: Vite dev server with HMR
- **nginx Features**:
  - Gzip compression
  - Static asset caching (1 year)
  - API proxy to backend
  - SPA fallback routing

## Docker Files

### Multi-Stage Dockerfiles

Both backend and frontend use multi-stage builds with separate targets:

**Backend Dockerfile (`docker/backend/Dockerfile`):**
- `base`: Common dependencies (Python, system packages)
- `development`: Includes dev tools (ipython, django-debug-toolbar)
- `production`: Optimized build with Gunicorn, non-root user

**Frontend Dockerfile (`docker/frontend/Dockerfile`):**
- `base`: Node.js base
- `development`: Vite dev server
- `builder`: Build React app
- `production`: nginx serving built files

### Configuration Files

1. **docker-compose.yml** - Production configuration
   - Uses `target: production` for builds
   - Runs Gunicorn and nginx
   - Production-grade settings

2. **docker-compose.dev.yml** - Development overrides
   - Uses `target: development` for builds
   - Volume mounts for hot reload
   - Development servers (runserver, Vite)

3. **docker/backend/gunicorn.conf.py** - Gunicorn configuration
   - Dynamic worker calculation: `(CPU cores * 2) + 1`
   - Worker lifecycle management
   - Logging to stdout/stderr
   - Performance optimizations (preload_app, worker_tmp_dir)

4. **docker/frontend/nginx.conf** - nginx configuration
   - Gzip compression
   - Static asset caching
   - API/media proxying to backend
   - SPA routing support
   - Security headers

## Environment Configuration

The `.env` file configures all services:

```bash
# Application
DEBUG=False
SECRET_KEY=<auto-generated-or-manual>
ALLOWED_HOSTS=localhost,yourdomain.com
CORS_ALLOWED_ORIGINS=http://localhost:3000

# Database
MYSQL_DATABASE=stock_tracking_db
MYSQL_USER=stock_user
MYSQL_PASSWORD=<set-this>
MYSQL_ROOT_PASSWORD=<set-this>
MYSQL_HOST=db
MYSQL_PORT=3306

# Redis
REDIS_URL=redis://redis:6379/0

# Gunicorn
GUNICORN_WORKERS=4
GUNICORN_LOG_LEVEL=info

# Frontend
VITE_API_URL=http://localhost:8000/api/v1
```

## Networking

All services run on a custom bridge network `stockdc-network`:
- Services can communicate using service names as hostnames
- Backend accessible at `http://backend:8000` from frontend
- Database accessible at `db:3306` from backend/worker
- Redis accessible at `redis:6379` from backend/worker

## Volumes

Three named volumes for persistent data:

1. **db_data**: MySQL database files
2. **static_data**: Django static files (CSS, JS, images)
3. **media_data**: User-uploaded files

Volumes persist even when containers are removed, ensuring data safety.

## Health Checks

All critical services have health checks:

```yaml
db:
  healthcheck:
    test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
    interval: 10s
    timeout: 5s
    retries: 5

redis:
  healthcheck:
    test: ["CMD", "redis-cli", "ping"]
    interval: 10s
    timeout: 3s
    retries: 5

backend:
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:8000/api/v1/health/"]
    interval: 30s
    timeout: 10s
    retries: 3
    start_period: 40s
```

## Development vs Production

### Development Mode
```bash
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up
```

**Characteristics:**
- Hot reload enabled (code changes reflect immediately)
- Volume mounts for source code
- Debug logging
- Django runserver + Vite dev server
- `DEBUG=True`
- Single Celery worker for easier debugging

### Production Mode
```bash
docker-compose up -d
```

**Characteristics:**
- Optimized builds
- Gunicorn WSGI server (4 workers)
- nginx serving static files
- Gzip compression
- Static asset caching
- `DEBUG=False`
- Multiple Celery workers
- Health checks enabled

## Makefile Commands

The `Makefile` provides InvenTree-style management:

### Installation & Setup
- `make install` - First-time setup
- `make start` - Start services
- `make stop` - Stop services
- `make restart` - Restart services

### Development
- `make dev` - Start dev environment
- `make dev-build` - Rebuild dev environment
- `make dev-bg` - Start dev in background

### Logs & Debugging
- `make logs` - All logs
- `make logs-backend` - Backend only
- `make logs-frontend` - Frontend only
- `make logs-worker` - Worker only

### Shell Access
- `make shell` - Backend bash
- `make shell-django` - Django shell
- `make dbshell` - MySQL shell
- `make redis-cli` - Redis CLI

### Django Commands
- `make migrate` - Run migrations
- `make makemigrations` - Create migrations
- `make superuser` - Create admin user
- `make test` - Run tests

### Database
- `make backup` - Backup database
- `make restore BACKUP=file.sql` - Restore
- `make db-reset` - Reset database (WARNING)

### Maintenance
- `make clean` - Remove all (WARNING)
- `make prune` - Clean unused resources
- `make rebuild` - Rebuild containers
- `make update` - Pull latest & rebuild
- `make deploy` - Production deployment

### Status
- `make status` - Service status
- `make health` - Health checks
- `make info` - Environment info

## Quick Start Script

The `scripts/docker-quickstart.sh` script automates setup:

```bash
./scripts/docker-quickstart.sh
```

**Features:**
- Checks Docker prerequisites
- Creates `.env` from `.env.example`
- Generates SECRET_KEY automatically
- Interactive setup (production/development)
- Post-installation instructions

## New Features Added

### Health Check Endpoint

A new health check endpoint was added for Docker health checks:

**Endpoint**: `GET /api/v1/health/`

**Checks**:
- Database connectivity
- Redis/cache connectivity

**Returns**:
- `200 OK` if all systems operational
- `503 Service Unavailable` if any system down

**Response Example**:
```json
{
  "status": "healthy",
  "timestamp": "2025-01-15T10:30:00",
  "checks": {
    "database": "ok",
    "cache": "ok"
  }
}
```

### Redis Caching

Django is now configured to use Redis for caching:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': os.getenv('REDIS_URL', 'redis://redis:6379/0'),
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        },
        'KEY_PREFIX': 'stockdc',
        'TIMEOUT': 300,
    }
}
```

**Benefits**:
- Faster API responses
- Reduced database load
- Session storage in Redis (production)
- Shared cache across multiple backend workers

## Security Features

1. **Non-root User**: Backend container runs as user `stockdc` (UID 1000)
2. **Security Headers**: nginx adds X-Frame-Options, X-Content-Type-Options, X-XSS-Protection
3. **Environment Variables**: Sensitive data in `.env` (not committed)
4. **Network Isolation**: Services on private bridge network
5. **Read-only Filesystem**: Static files served by nginx (not Django)

## Scaling

### Horizontal Scaling

**Scale Celery Workers**:
```bash
docker-compose up -d --scale worker=4
```

**Scale Gunicorn Workers**:
Set in `.env`:
```bash
GUNICORN_WORKERS=8  # (CPU cores * 2) + 1
```

### Load Balancing

For production at scale, add a reverse proxy:
- nginx (for simple load balancing)
- Traefik (for automatic SSL, service discovery)
- HAProxy (for advanced routing)

## Backup Strategy

### Automated Backups

Create a cron job:
```bash
# Daily backup at 2 AM
0 2 * * * cd /path/to/Stock-Tracking-DC && make backup
```

### Backup Locations

Backups stored in `backups/` directory:
```
backups/
├── backup_20250115_020000.sql
├── backup_20250114_020000.sql
└── ...
```

## Monitoring

### Basic Monitoring

```bash
# Service status
make status

# Health checks
make health

# Resource usage
docker stats
```

### Advanced Monitoring (Optional)

Add to `docker-compose.yml`:
```yaml
services:
  prometheus:
    image: prom/prometheus
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - "9090:9090"

  grafana:
    image: grafana/grafana
    ports:
      - "3001:3000"
```

## Troubleshooting

### Common Issues

**Port conflicts**:
```bash
# Change ports in docker-compose.yml
ports:
  - "8001:8000"  # Use 8001 instead of 8000
```

**Database not ready**:
```bash
# Wait for health check
docker-compose ps
# Should show "healthy"
```

**Permission errors**:
```bash
# Fix volume permissions
make shell
chown -R stockdc:stockdc /app/staticfiles /app/media
```

**Build cache issues**:
```bash
# Rebuild without cache
make rebuild
# Or
docker-compose build --no-cache
```

## References

- [Docker Documentation](https://docs.docker.com/)
- [Docker Compose Documentation](https://docs.docker.com/compose/)
- [InvenTree Docker Setup](https://docs.inventree.org/en/latest/start/docker/)
- [Django Deployment Checklist](https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/)
- [Gunicorn Configuration](https://docs.gunicorn.org/en/stable/configure.html)
- [nginx Configuration](https://nginx.org/en/docs/)

---

**Last Updated**: 2025-01-15
**Docker Compose Version**: 3.8
**InvenTree-Inspired**: ✓
